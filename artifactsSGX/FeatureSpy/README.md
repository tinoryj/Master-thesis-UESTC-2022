# FeatureSpy Simulator

The simulator is used to run the experiments in ยง6.2 in our paper. For brevity, we only focus on the simulation of the overall FeatureSpy (i.e., Exp#3 and Exp#4).

## Dependencies

FeatureSpy simulator is developed under Ubuntu 20.04.3 LTS and depends on the following packages that need to be installed manually or by the default `apt` package management tool.

1. OpenSSL version 1.1.1l [Donwload Link](https://www.openssl.org/source/old/1.1.1/openssl-1.1.1l.tar.gz)
2. libssl-dev (For FeatureSpy encryption algorithm)
3. clang/llvm (For compiling source code)
4. python (For faking offer file generator)
5. git (System components used for downloading Linux datasets)
6. curl/golang/jq (System components used for downloading CouchDB datasets)

The above packages can be installed via the `apt` package management tool with the following commands on Ubuntu.

```shell
sudo apt install -y build-essential openssl libssl-dev clang llvm python curl git golang jq
```

## Build

Compile and cleanup the FeatureSpy simulator as follows.

```shell
cd FeatureSpy
# compile
make
# cleanup
make clean
```

## Usage

## Manual

**Step 1:** Download the Linux/CouchDB datasets. The downloaded Linux and CouchDB snapshots will be saved in `FeatureSpy/traceDownload/linuxTrace` and `FeatureSpy/traceDownload/couchTrace/packed_enterprises`, respectively.

```shell
cd FeatureSpy/traceDownload
chmod +x *.sh
bash downloadTraceCouch.sh
bash downloadTraceLinux.sh
```

**Step 2:** Generate faked offers that enumerate salary and sign-on bonus.  We have packaged the original Google's offer letter in `FeatureSpy/SimulateOfferGenerator`. Alternatively, it is feasible to download the original offer from [here](https://www.sec.gov/Archives/edgar/data/1288776/000119312508140342/dex101.htm). In addition to the default range in our paper, you can modify the parameters in `generateFakeOffers.sh` to change the ranges and cardinalities of the salary and sign-on bonus, respectively. The generated offers are stored in the `FeatureSpy/SimulateOfferGenerator/result` directory.

```shell
cd FeatureSpy/SimulateOfferGenerator
chmod +x generateFakeOffers.sh
bash generateFakeOffers.sh
```

**Step 3:** Generate the list of the faked offer files.

```shell
cd FeatureSpy
chmod +x *.sh
# param 1: path to the folder where the target files are stored
# param 2: path to store the generated file list
bash generateFileList.sh SimulateOfferGenerator/result/ offer.fileList
```

An example of the file list is shown below. Each line corresponds to an adversarially faked file that enumerates the possible values of the salary and sign-on bonus.

```txt
/home/xxx/xxx/FeatureSpy/SimulateOfferGenerator/result/offer-base-204-30.html
/home/xxx/xxx/FeatureSpy/SimulateOfferGenerator/result/offer-base-204-31.html
/home/xxx/xxx/FeatureSpy/SimulateOfferGenerator/result/offer-base-204-32.html
/home/xxx/xxx/FeatureSpy/SimulateOfferGenerator/result/offer-base-204-33.html
/home/xxx/xxx/FeatureSpy/SimulateOfferGenerator/result/offer-base-204-34.html
...
```

**Step 4:** Generate the list of files in each Linux/CouchDB snapshot. Here we use Linux v5.13 as an example, and store the untared contents in in `FeatureSpy/v5.13`.

```shell
cd FeatureSpy
chmod +x *.sh
tar -xvf traceDownload/linuxTrace/v5.13.tar -C v5.13
# param 1: path to the folder where the target files are stored
# param 2: path to store the generated file list
bash generateFileList.sh v5.13 v5.13.fileList
```

**Step 5:** Randomly insert the faked offers into the target snapshot to form an attack snapshot, perform chunking on each individual file of the attack snapshot and output the sequential list of chunk metadata of the target snapshot.

```shell
cd FeatureSpy
make clean
make
# param 1: file list of inserted snapshots (generated by step 4); use v5.13.fileList as an example
# param 2: file list of fake offers (generated by step 3); use result.fileList as an example
# param 3: Redirect chunking's stdout to the specified file for recording chunk information; use test.chunkInfo as an example
./chunking v5.13.fileList result.fileList > test.chunkInfo
```

An example of the list of chunk metadata (`test.chunkInfo`) is shown below. The metadata contains the sequence number, hash, and size of each chunk.

```txt
0
C15D6659778FD34B4F62C8C069E0FCC86265D118B178BD4D11002C2F1DF22316
8894
1
ECD6F5A896E0900A368BDCCFFA8CA9BD94BFD50278A7025EB857A8F96487B7B6
7268
2
F438756CB77F09C31FBD80A36B3454BE34054F4403E1BABF5D8201D1A77AA553
2799
...
```

**Step 6:** Perform similarity-preserving encryption on each chunk, and detect the learning-content attack based on ciphertext chunks.

```shell
# param 1: Chunk info list generated by chunking; use test.chunkInfo as an example
# param 2: Window size (W); use the default  window size W=5000 as an example
# param 3: Indicator length (L) unit:block(16byte); use the default indicator length L=2 as an example
# param 4: detection threshold (T) unit:%; use the default threshold T=0.03 as an example
# param 5: Redirect FeatureSpy's stdout to the specified file for recording the maximum frequency of each window under the three schemes and duplicate statistics; use result-mixed.csv as an example
./FeatureSpy test.chunkInfo 5000 2 0.03 > result-mixed.csv
```

The output (in `stderr`) of `FeatureSpy` shows whether each scheme detects the learning-content attack (e.g., the `minFeature` scheme detected the attack, while `firstFeature` and `allFeature` schemes did not).

```shell
firstFeature: not detected
minFeature: detected
allFeature: not detected
```

The format of the `result-mixed.csv` file is as follows. Each row represents the fraction of the most number of chunks that have the same similarity indicator in a window.

| firstFeature | minFeature | allFeature |
| ------------ | ---------- | ---------- |
| 0.08         | 0.08       | 0.08       |
| 0.001        | 0.002      | 0.001      |
| 0.003        | 0.003      | 0.003      |

**Step 7 (optional):** If you want to test whether `FeatureSpy`  produces false positives on raw snapshots without inserting faked offers, you need to skip the second parameter of `chunking` (Step 5) and only perform chunking on the file list of the target snapshot. Then, run  `FeatureSpy` to get the result as in Step 6.


```shell
# param 1: file list of inserted snapshots (generated by step 4); use v5.13.fileList as an example
# param 2: Redirect chunking's stdout to the specified file for recording chunk information; use test.chunkInfo as an example
./chunking v5.13.fileList > test.chunkInfo
./FeatureSpy test.chunkInfo 5000 2 0.03 > result-raw.csv
```

## Automatic scripts

Alternatively, we provide a quick way to analyze the detection effectiveness. You can use `runCouch.sh` and `runLinux.sh` to test FeatureSpy with CouchDB and Linux, respectively, and use `processResult.sh` to output the summary of results. Note that you can modify the parameters in `runCouch.sh` and `runLinux.sh` to test different window sizes and similarity indicator lengths.

```shell
# download trace
cd FeatureSpy/traceDownload
chmod +x *.sh
bash downloadTraceCouch.sh
bash downloadTraceLinux.sh
# generate fake offers
cd FeatureSpy/SimulateOfferGenerator
chmod +x generateFakeOffers.sh
bash generateFakeOffers.sh
# test with CouchDB and Linux trace
cd FeatureSpy/
chmod +x *.sh
bash runCouch.sh
bash runLinux.sh
bash processResult.sh
```

In the running of `runLinux.sh`/`runCouch.sh`, the program processes each snapshot and outputs the detection results in the command line (via `stderr`).

```shell
firstFeature: not detected
minFeature: detected
allFeature: not detected
```

Also, it saves the feature distribution information of each window of the processing snapshot in `FeatureSpy/linuxResult/` and  `FeatureSpy/couchResult/` for Linux and CouchDB dataset, respectively. The file name of each raw snapshot is `${snpashotID}-origin-${windowSize}-${indicatorLength}.csv`, while that of each attack snapshot (i.e., adversarially injected with fake offers) is `${snpashotID}-mixed-${windowSize}-${indicatorLength}.csv`. An example file is shown as follows, where each row represents the fraction of the most number of chunks that have the same similarity indicator in a window.

| firstFeature | minFeature | allFeature |
| ------------ | ---------- | ---------- |
| 0.08         | 0.08       | 0.08       |
| 0.001        | 0.002      | 0.001      |
| 0.003        | 0.003      | 0.003      |

Furthermore, the script `processResult.sh` generates the file `mergedLinuxResult-${windowSize}-${indicatorLength}.csv`/`mergedCouchResult-${windowSize}-${indicatorLength}.csv` to summarize the final results of attack detection for all snapshots (see below). Each row represents the maximum fraction of the most number of chunks that have the same similarity indicator among all windows in each snapshot. Note that the raw (mixed) here means the snapshot without (with) injected faked offers.

| firstFeature max freq (raw) | minFeature max freq (raw) | allFeature max freq (raw) | firstFeature max freq (mixed) | minFeature max freq (mixed) | allFeature max freq (mixed) |
| :-------------------------- | ------------------------- | ------------------------- | ----------------------------- | --------------------------- | --------------------------- |
| 0.0032                      | 0.0028                    | 0.0028                    | 0.1106                        | 0.1106                      | 0.1106                      |
| 0.003                       | 0.003                     | 0.003                     | 0.1022                        | 0.1022                      | 0.1022                      |
| 0.0026                      | 0.0024                    | 0.0024                    | 0.1026                        | 0.1026                      | 0.1026                      |
| 0.0026                      | 0.0022                    | 0.0022                    | 0.0972                        | 0.0972                      | 0.0972                      |
