\subsection{安全区管理}
\label{subsec:enclave-management}

\sysname 在首次初始化时通过云建立对所有安全区的信任。在部署 \sysname 之前，我们首先将 enclave 代码编译成共享对象 \cite{sgx}，为每个共享对象附加签名（用于完整性验证），并将共享对象分发到密钥服务器和每个客户端。云还托管共享对象以供后续验证。密钥服务器创建密钥安全区，而每个客户端通过加载相应的共享对象来创建自己的 PoW 安全区。云通过远程证明 (\S\ref{subsec:sgx}) 对每个 enclave 进行身份验证，以确保加载正确的代码。在这里，我们解决了两个特定的管理问题：（i）如何将全局机密（\S\ref{subsec:arch}）安全地引导到密钥安全区； (ii) 每个客户端在重启后如何有效地引导其 PoW 安全区。

\paragraph{Key enclave management.} \sysname 不是完全引导全局密钥，而是根据云和密钥服务器分别拥有的两个 {\em sub-secrets} 在密钥安全区中生成全局密钥，以便阻止他们中的任何一个了解整个全球秘密。
为了生成全局密钥，我们将云的子密钥硬编码到密钥安全区代码中，并在 SGXDedup 初始化期间将代码（作为共享对象）传递给密钥服务器。我们还为密钥安全区实现了一个{\em secret generation ECall}，以便让密钥服务器提供自己的子密钥。只有在云的子密钥被包含在密钥安全区中后，密钥服务器才能发出 ECall。它将密钥服务器的子密钥作为其单一输入，并对密钥服务器的子密钥和云的子密钥的串联进行哈希运算，形成全局密钥。请注意，密钥服务器无法访问 enclave 代码，因此无法了解在 enclave 内硬编码的云子秘密（假设逆向工程是不可能的）。因此，即使密钥服务器遭到破坏，全局机密仍然是安全的，因此服务器辅助 MLE 的安全性得以保留。如果密钥服务器和云同时受到威胁，\sysname 的安全性会降低到原始 MLE (\S\ref{subsec:encrypted-dedup}) 的安全性。

\paragraph{PoW enclave 管理。} 当客户端启动其 PoW enclave 时，它​​需要证明 PoW enclave 的真实性。但是，远程证明通常会产生非常大的延迟（例如，大约 9\,s；请参阅 \S\ref{subsec:synthetic}）以连接到英特尔服务。与 key enclave 不同，其远程证明只在初始化期间完成一次，客户端每次加入和离开 \sysname 时都需要分别引导和终止 PoW enclave。如果每次客户端加入时都使用远程证明，其大量开销将损害可用性。

\sysname 在 PoW enclave 的第一次引导后利用密封来避免远程证明。回想一下，PoW 安全区与云共享一个 PoW 密钥，这样云就可以验证指纹的真实性 (\S\ref{subsec:arch})。我们的想法是根据 PoW enclave 的测量哈希来密封 PoW 密钥。因此，当客户端再次引导其 PoW 安全区时，它会将 PoW 密钥解封到引导的 PoW 安全区中。只要成功恢复 PoW 密钥，就可以验证自举 PoW enclave 的真实性。

具体来说，客户端首先检查其物理机中是否有任何密封的 PoW 密钥在本地可用。如果密封的 PoW 密钥不可用（第一个引导程序），客户端通过远程证明来证明 PoW 安全区并与云交换 PoW 密钥；否则，如果一个密封的 PoW 密钥可用（在第一次引导之后），客户端通过加载共享对象创建一个新的 PoW enclave，并调用新 PoW enclave 的 {\em key unsealing ECall} 来解封 PoW 密钥。解封 ECall 的密钥以被密封的 PoW 密钥的地址作为输入。它根据新 PoW enclave 的测量散列推导出密封密钥，解密密封的 PoW 密钥，并将其保存在新的 PoW enclave 中。

当客户端离开 \sysname 时，它​​的 PoW enclave 需要被终止。客户端发出 {\em key seal ECall} 来密封 PoW 密钥。密钥密封 ECall 根据 PoW enclave 的测量哈希对 PoW 密钥进行加密，并将结果存储在客户端提供的地址中。