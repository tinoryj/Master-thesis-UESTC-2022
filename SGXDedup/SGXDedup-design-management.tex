\subsection{安全区管理}
\label{subsec:sgxdedup-enclave-management}

\sysnameS 在首次初始化时通过云服务端建立对所有安全区的信任。在\sysnameS 部署之前，本文首先将安全区代码编译为动态连接库\cite{sgx}，为每个动态连接库附加签名(用于完整性验证)，并将动态连接库分发到密钥服务器和每个客户端。云服务端保留密钥安全区及所有权证明安全区的动态连接库及相关签名以供后续验证。在初始化过程中，密钥服务器加载该动态链接库以创建密钥安全区，而每个客户端通过加载相应的动态连接库来创建自己的所有权证明安全区。云服务端通过远程证明(\S\ref{subsec:sgxdedup-sgx})对每个安全区进行验证，确保其已加载正确的安全区动态链接库并正确运行。这里，本文重点解决了两个特定的安全区管理问题：

\begin{itemize}[leftmargin=0em]
    \item 如何将全局秘密(\S\ref{subsec:sgxdedup-arch})安全地装载到密钥安全区中，确保密钥服务器及云服务端均无法了解全局秘密的所有信息。
    \item 每个客户端在重新启动后如何有效地加载并初始化(避免重复进行昂贵的远程证明)其所有权证明安全区。
\end{itemize}

\paragraph*{密钥安全区管理。}\sysnameS 不直接为密钥安全区装载完整的全局秘密，而是根据云服务商和密钥服务器分别拥有的两个子秘密(Sub-secret)在密钥安全区启动后在安全区内生成全局秘密，防止云服务商或密钥服务器中任意一方了解完整的全局秘密。

为了生成全局秘密，本文将云服务端的子秘密硬编码到密钥安全区代码中，并在 \sysnameS 初始化之前将代码(以安全区动态连接库形式)传递给密钥服务器。本文为密钥安全区实现了\textit{Secret generation ECall}，以便密钥服务器向安全区提供自己的子秘密。安全区将密钥服务器的子秘密作为该Ecall的输入，并对密钥服务器的子秘密和云服务端的子秘密的串联结果进行哈希运算，形成全局秘密。由于密钥服务器无法访问安全区代码，因此无法了解在安全区内硬编码的云服务端子秘密(假设逆向工程不可行)。因此，即使密钥服务器遭到攻击，全局秘密仍然是安全的。使得服务器辅助消息锁加密的安全性得以保障。如果密钥服务器和云服务端同时受到攻击，\sysnameS 中服务器辅助密钥生成的安全性会降低到原始消息锁加密的安全性。

\paragraph*{所有权证明安全区管理。} 当客户端启动其所有权证明安全区时，它​​需要证明所有权证明安全区的真实性。但是，由于远程证明通常会产生较高且波动性显著的延迟(例如，大约 9\,s；请参阅 \S\ref{subsec:sgxdedup-synthetic})以连接到Intel服务。与密钥安全区不同，密钥安全区远程证明只在初始化期间完成一次即可，而客户端每次加入和离开 \sysnameS 时都需要分别启动和终止所有权证明安全区。如果每次客户端加入时都使用远程证明，其大量开销将严重降低\sysnameS 系统的可用性。

\sysnameS 在所有权证明安全区的第一次启动后利用密封来避免远程证明。由于所有权证明安全区与云服务端共享一个PoW密钥以实现云服务端对数据块指纹真实性的验证(\S\ref{subsec:sgxdedup-arch})。本文提出根据所有权证明安全区的测量哈希生成密封密钥来密封PoW密钥。因此，当客户端再次启动其所有权证明安全区时，它会将PoW密钥解封到启动的所有权证明安全区中。只要成功恢复PoW密钥，就可以自举验证所有权证明安全区的真实性。

具体来说，客户端首先检查其物理机中是否有任何密封的PoW密钥在本地可用。如果密封的PoW密钥不可用(例如，首次启动所有权证明安全区)，客户端通过远程证明来证明所有权证明安全区的真实性并与云服务端交换PoW密钥；而如果一个密封的PoW密钥可用(例如，在第一次启动所有权证明安全区之后)，客户端通过加载动态连接库创建一个新的所有权证明安全区，并调用新所有权证明安全区的\textit{key unsealing ECall}来解封PoW密钥。该安全区内部调用以被密封的PoW密钥在未受保护内存中的地址作为输入，并根据新所有权证明安全区的测量哈希推导出密封密钥(由于安全区来自同一个动态链接库，因此测量哈希相同)，解密密封的PoW密钥，并将其保存在新的所有权证明安全区中。

当客户端离开\sysnameS 时，它​​的所有权证明安全区需要被终止。此时，客户端发出\textit{key seal ECall}来密封PoW密钥。该安全区内部调用根据所有权证明安全区的测量哈希派生的密封密钥对PoW密钥进行加密，并将结果存储在客户端提供的地址中。