\subsection{安全区管理}
\label{subsec:sgxdedup-enclave-management}

\sysnameS 在首次初始化时通过云建立对所有安全区的信任。在部署 \sysnameS 之前，本文首先将安全区代码编译成共享对象 \cite{sgx}，为每个共享对象附加签名（用于完整性验证），并将共享对象分发到密钥服务器和每个客户端。云还托管共享对象以供后续验证。密钥服务器创建密钥安全区，而每个客户端通过加载相应的共享对象来创建自己的所有权证明安全区。云通过远程证明 (\S\ref{subsec:sgxdedup-sgx}) 对每个安全区进行身份验证，以确保加载正确的代码。在这里，本文解决了两个特定的管理问题:（i）如何将全局秘密（\S\ref{subsec:sgxdedup-arch}）安全地引导到密钥安全区； (ii) 每个客户端在重启后如何有效地引导其所有权证明安全区。

\paragraph*{Key安全区management.} \sysnameS 不是完全引导全局密钥，而是根据云和密钥服务器分别拥有的两个 \textit{ sub-secrets} 在密钥安全区中生成全局密钥，以便阻止他们中的任何一个了解整个全球秘密。
为了生成全局密钥，本文将云的子密钥硬编码到密钥安全区代码中，并在 \sysnameS 初始化期间将代码（作为共享对象）传递给密钥服务器。本文还为密钥安全区实现了一个\textit{ secret generation ECall}，以便让密钥服务器提供自己的子密钥。只有在云的子密钥被包含在密钥安全区中后，密钥服务器才能发出 ECall。它将密钥服务器的子密钥作为其单一输入，并对密钥服务器的子密钥和云的子密钥的串联进行哈希运算，形成全局密钥。请注意，密钥服务器无法访问安全区代码，因此无法了解在安全区内硬编码的云子秘密（假设逆向工程是不可能的）。因此，即使密钥服务器遭到破坏，全局秘密仍然是安全的，因此服务器辅助 消息锁加密（MLE） 的安全性得以保留。如果密钥服务器和云同时受到威胁，\sysnameS 的安全性会降低到原始 消息锁加密（MLE） (\S\ref{subsec:sgxdedup-encrypted-dedup}) 的安全性。

\paragraph*{所有权证明安全区管理。} 当客户端启动其 所有权证明安全区时，它​​需要证明 所有权证明安全区的真实性。但是，远程证明通常会产生非常大的延迟（例如，大约 9\,s；请参阅 \S\ref{subsec:sgxdedup-synthetic}）以连接到Intel服务。与 key安全区不同，其远程证明只在初始化期间完成一次，客户端每次加入和离开 \sysnameS 时都需要分别引导和终止 PoW enclave。如果每次客户端加入时都使用远程证明，其大量开销将损害可用性。

\sysnameS 在 所有权证明安全区的第一次引导后利用密封来避免远程证明。回想一下，PoW 安全区与云共享一个PoW Key，这样云就可以验证指纹的真实性 (\S\ref{subsec:sgxdedup-arch})。本文的想法是根据 所有权证明安全区的测量哈希来密封PoW Key。因此，当客户端再次引导其所有权证明安全区时，它会将PoW Key解封到引导的所有权证明安全区中。只要成功恢复PoW Key，就可以验证自举 所有权证明安全区的真实性。

具体来说，客户端首先检查其物理机中是否有任何密封的PoW Key在本地可用。如果密封的PoW Key不可用（第一个引导程序），客户端通过远程证明来证明所有权证明安全区并与云交换PoW Key；否则，如果一个密封的PoW Key可用（在第一次引导之后），客户端通过加载共享对象创建一个新的 PoW enclave，并调用新 所有权证明安全区的 \textit{ key unsealing ECall} 来解封PoW Key。解封 ECall 的密钥以被密封的PoW Key的地址作为输入。它根据新 所有权证明安全区的测量散列推导出密封密钥，解密密封的PoW Key，并将其保存在新的 所有权证明安全区中。

当客户端离开 \sysnameS 时，它​​的 所有权证明安全区需要被终止。客户端发出 \textit{ key seal ECall} 来密封PoW Key。密钥密封 ECall 根据 所有权证明安全区的测量哈希对PoW Key进行加密，并将结果存储在客户端提供的地址中。