\section{\sysnameS 实现}
\label{sec:sgxdedup-implementation}

本文基于OpenSSL 1.1.1l\cite{openssl}、SGX SDK 2.15\cite{sgxsdk} 、和Intel SGX SSL\cite{sgxssl}使用C++实现了一个\sysnameS 原型系统。本文的原型系统通过SHA-256哈希函数实现明文和密文数据块的指纹计算和识别等操作，并通过AES-256加密算法实现基于数据块的加密机制。原型系统约包含14,200行代码。

\paragraph*{原型系统启动：} 
为了启动密钥安全区，云服务端将对其用于全局秘密生成的子秘密（\S\ref{subsec:sgxdedup-enclave-management}）和盲密钥种子（\S\ref{subsec:sgxdedup-key-management}）硬编码到密钥安全区动态运行库中。\sysnameS 中云服务端也可以在验证密钥安全区后再通过安全信道向密钥安全区装载子秘密和盲密钥种子（使用SGX\cite{sgx}的秘密提供（secret provisioning）功能），但会产生额外的启动开销。密钥安全区使用SHA-256哈希算法生成全局秘密并在密钥回归中进行密钥状态更新和盲密钥导出。每个所有全证明安全区都在NIST P-256椭圆曲线上实现DHKE，以与云服务端共享PoW密钥。

\paragraph*{密钥生成：}每个客户端实现了基于Rabin指纹\cite{rabin81}的内容定义的数据块分块。本文将可变大小分块算法中的最小、平均和最大数据块大小分别固定为4\,KiB，8\,KiB和16\,KiB。为了实现基于TEE的推测性加密、(\S\ref{subsec:sgxdedup-encryption})，本文将nonce和计数器长度分别固定为12字节和4字节，并使用HMAC-SHA-256实现消息认证算法。此外，密钥安全区通过SHA-256哈希算法生成每个明文数据块指纹对应的消息锁加密密钥。

\paragraph*{重复数据删除：}\sysnameS 实现了源端重复数据删除与数据块级所有权证明的结合。所有权证明安全区实现了所有权证明安全区内部调用（\textit{proof generation ECall}）来计算密文数据块的指纹，并使用AES-CMAC对生成的指纹生进行签名。云服务端基于LevelDB\cite{leveldb}键值对数据块实现重复数据删除指纹索引（\S\ref{subsec:sgxdedup-problem}）。为了降低网络和磁盘I/O开销，本文将非重复密文数据块存储在8\,MiB的容器中，作为传输和存储的基本单位\cite{lillibridge13}。

\paragraph*{系统优化：}为了减少频繁进出安全区导致的CPU上下文切换和安全区内存加密/解密开销，每个客户端批量处理多个明文数据块指纹（默认为4,096个）进行密钥生成请求并在与密钥安全区（\S\ref{subsec:sgxdedup-encryption}）之间的安全信道中传输。密钥安全区通过指针访问未受保护的内存读取数据块指纹进行批量消息锁加密密钥生成，而不将指纹内容复制到安全区\cite{harnik2018SGX}。类似地，所有权证明安全区按批次（默认为4,096）处理密文数据块且不复制密文数据块内容到安全区内。本文还使用多线程来提高性能，每个客户端通过多线程并行处理文件分块、明文数据块计算、密钥生成及加密、所有权证明和非重复数据块及元数据上传。同时，密钥安全区和云服务端使用不同线程处理多个客户端的连接。